//
//  QuickSort.h
//  SortDemo
//
//  Created by 夏志勇 on 2019/11/18.
//  Copyright © 2019 夏志勇. All rights reserved.
//  6.快速排序 Quick Sort 在冒泡排序基础上的递归分治法，将一个串行分成两个子串行

/*
 基本思想：为基准数找出正确的索引位置；即以基准数为分界点，将数组分成两个子数组；
 升序：基准数左边所有数均比基准数小，基准数右边所有数均比基堆数大。。。[将比基准数大的都放在基准数右边，将比基准数小的都放在基准数左边]。
 降序: 与升序相反。
 
 通常情况下，[快速排序]优化[归并排序]:
 快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。
 但它的平摊期望时间是O(nlogn)，且O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于O(nlogn)的归并排序要小很多。
 所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
 
 快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
 1>首先设定一个分界值，通过该分界值将数组分成左右两部分。
 2>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
 3>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
 4>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。
 */

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface QuickSort : NSObject

+ (NSArray *)quickSort:(NSArray *)list;

@end

NS_ASSUME_NONNULL_END
