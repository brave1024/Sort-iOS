//
//  CountSort.h
//  SortDemo
//
//  Created by 夏志勇 on 2019/11/21.
//  Copyright © 2019 夏志勇. All rights reserved.
//  8.计数排序 Counting Sort

/*
 算法思想：
 计数排序是一个非基于比较的排序算法。
 
 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。
 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
 
 元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。
 计数排序过程中不存在元素之间的比较和交换操作；
 根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。
 
 计数排序的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。
 当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）
 
 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
 
 算法步骤：
 1.根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；
 2.遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；
 3.对额外空间内数据进行计算，得出每一个元素的正确位置；
 4.将待排序集合每一个元素移动到计算得出的正确位置上。
 
 1> 时间复杂度：O(n+k) (k是整数的范围)
 2> 空间复杂度：O(n+k)
 3> 稳定性：稳定
 4> 排序类别：非比较排序（线性时间排序算法）
 */

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface CountSort : NSObject

+ (NSArray *)countSort:(NSArray *)list;

@end

NS_ASSUME_NONNULL_END
